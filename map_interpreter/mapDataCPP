#include "MapData.hpp"

/** ----------- **/
/** Collectible **/
/** ----------- **/

// Collectible::Collectible(): Constructor for Collectible Class
Collectible::Collectible(const Point &p, const unsigned short &c) {
    Collectible::pos_ = p;
    Collectible::color_ = c;
}

// Getter for Collectible::pos_
Point Collectible::pos() {
    return Collectible::pos_;
}

// Getter for Collectible::color_
int Collectible::color() const {
    return Collectible::color_;
}

/** ----------- **/
/**     Line    **/
/** ----------- **/

// Line::Line(): Constructor for Line Class
Line::Line(const Point &p1, const Point &p2) {
    /** Set private vars **/
    Line::p1_ = p1;
    Line::p2_ = p2;
}

// Getter for Line::p1_
Point Line::p1() {
    return Line::p1_;
}

// Getter for Line::p2_
Point Line::p2() {
    return Line::p2_;
}


// Line::intersects():  Test if a line l intersects Line::
//      Input:  Line l
//      Return: intersection Point if existing. Otherwise {-1,-1}
Point Line::intersects(Line &l) {
    // line - line intersection using determinants:
    // source: https://en.wikipedia.ord/wiki/Line%E2%%80%90line_intersection

    // determiant = x1 * y2- x2 * y1
    int L1 = Line::p1().x * Line::p2().y - Line::p2().x * Line::p1().y;
    int L2 = l.p1().x * l.p2().y - l.p2().x * l.p1().y;

    // difs
    int L1xdif = Line::p1().x - Line::p2().x;
    int L1ydif = Line::p1().y - Line::p2().y;
    int L2xdif = l.p1().x - l.p2().x;
    int L2ydif = l.p1().y - l.p2().y;

    // determiant a*d - b*c
    double xnom = L1 * L2xdif - L2 * L1xdif;
    double ynom = L1 * L2ydif - L2 * L2ydif;
    double denom = L1xdif * L2ydif - L2xdif * L1ydif;

    // Lines don't cross
    if (denom == 0) {
        return {-1, -1};
    }
    // return intersection
    return {static_cast<int>(round(xnom / denom)), static_cast<int>(round(ynom / denom))};
}

/** ----------- **/
/**     Area    **/
/** ----------- **/

// Area::Area(): Constructor for Area class
Area::Area(const std::vector <Point> &p_s) {

    // xmin = 0, ymin = 0;
    Area::min = {65665, 65665};
    // xmax = Infinity, ymax = Infinity;
    Area::max = {0, 0};

    Area::edges = p_s;
    Point last_p = p_s.back();
    for (Point p : p_s) {
        Area::bounds_.emplace_back(last_p, p);
        last_p = p;

        // Set boundary box x
        if (p.x < Area::min.x) {
            Area::min.x = p.x;
        }
        if (p.x > Area::max.x) {
            Area::max.x = p.x;
        }

        // Set boundary box y
        if (p.y < Area::min.y) {
            Area::min.y = p.y;
        }
        if (p.y > Area::max.y) {
            Area::max.y = p.y;
        }
    }
}

// geometry::onSide():  Test if a point p2 is left/on/right a line through p0 and p1.
//      Input:  Point p0, p1, p2
//      Return: >0 left; =0 on; <0 right
namespace geometry {
    int onSide(Point p0, Point p1, Point p2) {
        return ((p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y));
    }
};

// Area::isInside():  winding number test for a point in area/polygon
//      Input:  Point p
//      Return: wn != 0 <=> true
bool Area::isInside(const Point &p) const {
    // Point in Polygon(PIP) using the winding number algorithm:
    // source: https://en.wikipedia.ord/wiki/Point_in_polygon

    int wn = 0;    // the  winding number counter

    std::vector <Point> poly = Area::edges;      // vector with
    poly.push_back(poly.front());

    // loop through all edges of the polygon
    for (unsigned int i = 0; i < Area::edges.size(); i++) {     // edge from V[i] to  V[i+1]
        if (poly[i].y <= p.y) {                                 // start y <= P.y
            if (poly[i + 1].y > p.y)                            // an upward crossing
                if (geometry::onSide(poly[i], poly[i + 1], p) > 0)        // P left of  edge
                    ++wn;                                       // have  a valid up intersect
        } else {                                                // start y > P.y (no test needed)
            if (poly[i + 1].y <= p.y)                           // a downward crossing
                if (geometry::onSide(poly[i], poly[i + 1], p) < 0)        // P right of  edge
                    --wn;                                       // have  a valid down intersect
        }
    }
    return wn != 0;
}

/** ----------- **/
/**   MapData   **/
/** ----------- **/

// Field::Field(): Constructor for Field class
Field::Field(const int &width, const int &height,
             const std::vector <Area> &walls,
             const std::vector <Point> &wnodes,
             const std::vector <Area> &traps,
             const std::vector <Point> &tnodes,
             const std::vector <Area> &swamps,
             const std::vector <Point> &deposits,
             const std::vector <Area> &waters,
             const std::vector <std::vector<Collectible>> &collectibles) {

    Field::size_ = {width, height};

    Field::Walls = walls;
    Field::wNodes = wnodes;
    Field::Traps = traps;
    Field::tNodes = tnodes;
    Field::Swamps = swamps;
    Field::Deposits = deposits;
    Field::Waters = waters;

    Field::Collectibles = collectibles;
}

/** Getter for Field::size **/
std::pair<int, int> Field::size() {
    return Field::size_;
}
