#include "MapData.hpp"

MapData::MapData(int mapX, int mapY,
                 std::vector<std::pair<int, int>> *redPoints,
                 std::vector<std::pair<int, int>> *greenPoints,
                 std::vector<std::pair<int, int>> *blackPoints,
                 std::vector<std::pair<int, int>> *deposits,
                 std::vector<std::pair<int, int>> *walls,
                 std::vector<std::pair<int, int>> *traps,
                 std::vector<std::pair<int, int>> *swamps) {
    // Map Init
    MapData::MapX = mapX;
    MapData::MapY = mapY;
    for (int i = 0; i < MapX; i++) {
            const std::vector<int> _v;
            MapData::Map.push_back(_v);
            for (int j = 0; j < MapY; j++) {
                MapData::Map[i].push_back(0);
            }
        }
    for (std::pair<int, int> wall : *walls) {
        MapData::Map[wall.first][wall.second] = 1;
    }
    for (std::pair<int, int> trap : *traps) {
        MapData::Map[trap.first][trap.second] = 2;
    }
    for (std::pair<int, int> swamp : *swamps) {
        MapData::Map[swamp.first][swamp.second] = 3;
    }

    // Deposit Areas
    for (std::pair<int, int> deposit : *deposits) {
        MapData::DepositAreas.push_back(deposit);
    }

    // Point Init
    for (auto p : *redPoints) {
        MapData::RedPoints.emplace_back(p.first, p.second, deposits, 1);
    }
    for (auto p : *greenPoints) {
        MapData::GreenPoints.emplace_back(p.first, p.second, deposits, 2);
    }
    for (auto p : *blackPoints) {
        MapData::BlackPoints.emplace_back(p.first, p.second, deposits, 3);
    }

    for (auto p : MapData::RedPoints, MapData::GreenPoints, MapData::BlackPoints) {
        MapData::AllPoints.push_back(&p);
    }

    // calculate distances
    for (auto p : MapData::AllPoints) {
        p->calculate_closest_points(&this->AllPoints);
    }
}
int MapData::getPointCount(int pColor) {
    return MapData::getPtrToArr(pColor)->size();
}
int MapData::findPoint(std::pair<int, int> p, const int pColor) {
    std::vector<Point> *ptr = MapData::getPtrToArr(pColor);

    for (unsigned int i = 0; i < ptr->size(); i++) {
        if (ptr->at(i).pos() == p) {
            return static_cast<int>(i);
        }
    }
    return -1;
}
int MapData::erasePoint(const std::pair<int, int> p, const int pColor) {
    std::vector<Point> *ptr = MapData::getPtrToArr(pColor);
    int i = findPoint(p, pColor);
    if (i >= 0) {
        ptr->erase(ptr->begin() + i);
        return 1;
    }
    return 0;
}
int MapData::erasePoint(const int index, const int pColor) {
    std::vector<Point> *ptr = MapData::getPtrToArr(pColor);
    if (index >= 0 && index < static_cast<int>(ptr->size())) {
        ptr->erase(ptr->begin() + index);
        return 1;
    }
    return 0;
}
std::pair<int, int> MapData::getPoint(const int index, const int pColor) {
    std::vector<Point> *ptr = MapData::getPtrToArr(pColor);

    if (static_cast<unsigned int>(index) < ptr->size() && index >= 0) {
        return ptr->at(index).pos();
    } else {
        // TODO: Throw exeption
        return ptr->at(0).pos();
    }
}
std::vector<Point> *MapData::getPtrToArr(const int pColor) {
    switch (pColor) {
        case 0:
            return &this->RedPoints;
        case 1:
            return &this->GreenPoints;
        case 2:
            return &this->BlackPoints;
        default:
            // TODO: Throw exeption;
            return &this->RedPoints;
    }
}

std::vector<std::pair<int, int>> MapData::getDepositAreas() {
    return MapData::DepositAreas;
}

int MapData::availableColors() {
    int sum = 0;
    if (MapData::getPointCount(0) > 0) {
        sum += 1;
    }
    if (MapData::getPointCount(1) > 0) {
        sum += 2;
    }
    if (MapData::getPointCount(2) > 0) {
        sum += 4;
    }
    return sum;
}

std::vector<std::array<int, 3>> MapData::getAllPoints() {

    std::vector<std::array<int, 3>> all_points;
    for (auto point : MapData::AllPoints) {
        all_points.push_back({point->pos().first, point->pos().second, point->color()});
    }
    return all_points;
}

std::vector<std::pair<int, int>> MapData::getNodes() {
    return MapData::Nodes;
}

