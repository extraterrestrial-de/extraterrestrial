#include "MapData.hpp"

#define ERROR_MESSAGE(MESSAGE) {std::cerr << __FUNCTION__ << "\t" << MESSAGE << std::endl;}


MapData::MapData(int mapX, int mapY,
                 std::vector<std::pair<int, int>> *redPoints,
                 std::vector<std::pair<int, int>> *greenPoints,
                 std::vector<std::pair<int, int>> *blackPoints,
                 std::vector<std::pair<int, int>> *deposits,
                 std::vector<std::pair<int, int>> *walls,
                 std::vector<std::pair<int, int>> *traps,
                 std::vector<std::pair<int, int>> *swamps) {

    // #########  map  ##########
    MapData::MapX = mapX;
    MapData::MapY = mapY;
    for (int i = 0; i < MapX; i++) {
        const std::vector<int> _v;
        MapData::Map.push_back(_v);
        for (int j = 0; j < MapY; j++) {
            MapData::Map[i].push_back(0);
        }
    }
    for (const std::pair<int, int> &wall : *walls) {        // walls
        MapData::Map[wall.first][wall.second] = 1;
    }
    for (const std::pair<int, int> &trap : *traps) {        // traps
        MapData::Map[trap.first][trap.second] = 2;
    }
    for (const std::pair<int, int> &swamp : *swamps) {      // swamps
        MapData::Map[swamp.first][swamp.second] = 3;
    }
    for (const std::pair<int, int> &deposit : *deposits) {  // deposit_areas
        MapData::DepositAreas.push_back(deposit);
    }

    // ########  points  ############
    for (auto & redPoint : *redPoints) {                   // red_points
        MapData::RedPoints.emplace_back(&redPoint, 0);
    }
    for (auto & greenPoint : *greenPoints) {
        MapData::GreenPoints.emplace_back(&greenPoint, 1);      // green_points/cyan_points
    }
    for (auto & blackPoint : *greenPoints) {
        MapData::BlackPoints.emplace_back(&blackPoint, 2);      // green_points/cyan_points
    }

    // Push everything to all_points
    for (auto & point : MapData::RedPoints) {
        MapData::AllPoints.push_back(&point);
    }
    for (auto & point : MapData::GreenPoints) {
        MapData::AllPoints.push_back(&point);
    }
    for (auto & point : MapData::BlackPoints) {
        MapData::AllPoints.push_back(&point);
    }

    ERROR_MESSAGE("Printing Points out of getAllPoints()")
    for (auto a : MapData::getAllPoints()) {
        ERROR_MESSAGE("Point: " + str(a->pos) + " #" + std::to_string(a->color))
    }
    /*// ########  calculate distances  #########
    for (auto p : MapData::AllPoints) {
        p->init(MapData::getAllPoints());
    }*/
}

Point *MapData::find_point(std::pair<int, int> p, const int _color) {
    std::vector<Point> *ptr = MapData::get_ptr_to_arr(_color);

    for (auto &i : *ptr) {
        if (i.dist(p) < 5) {
            return &i;
        }
    }

    std::cerr << __FUNCTION__ << " P(" << std::to_string(p.first) << "" << std::to_string(p.second) << ") | c("
              << std::to_string(_color) << ") is not existing";
    return nullptr;
}

std::vector<Point> *MapData::get_ptr_to_arr(const int &_color) {
    switch (_color) {
        case 0:
            return &this->RedPoints;
        case 1:
            return &this->GreenPoints;
        case 2:
            return &this->BlackPoints;
        default:
            std::cerr << __FUNCTION__ << " color: " << std::to_string(_color) << " is not valid";
            return &this->RedPoints;
    }
}

std::vector<std::pair<int, int>> MapData::getDepositAreas() {
    return MapData::DepositAreas;
}

std::vector<Point *> MapData::getAllPoints() {
    return MapData::AllPoints;
}

std::pair<std::vector<Point *>, std::pair<int, int>> MapData::get_path(std::array<int, 3>
                                                    loaded_objects, int loaded_objects_num,
                                                    std::pair<int, int> pos) {
    // point array which which will later be returned
    std::vector<Point *> point_path;

    // point finding algorithm. (See Idea 4 on https://stackoverflow.com/questions/62179174)
    //      This isn't an optimal solution

    double b_overall_dist = -1;
    std::pair<int, int> t_deposit_area;

    for (auto deposit_area : MapData::getDepositAreas()) {

        ERROR_MESSAGE("Next Deposit_Area")
        std::array<int, 3> t_loaded_objects = loaded_objects;
        int t_loaded_objects_num = loaded_objects_num;
        // temporary array to be able to compare
        std::vector<Point *> cur_path;

        // cur_path_dist is used to decide which route to which deposit_area to pick
        double cur_path_dist = 0;

        // add upto 6 points to cur_path;
        for (int i = t_loaded_objects_num; i < 6; ++i) {

            Point *b_point = nullptr;
            double b_f_cost = -1;

            // getAllPoints() returns a vector<array<int, 3>>:
            //      get the point with the lowest f
            for (const auto &point : MapData::getAllPoints()) {

                // check if the object_type is chosen less or equal to 2 times
                if (t_loaded_objects[point->color] < 2) {
                    // g_dist is the dist from the last chosen point to the current point
                    double g_dist = 0;
                    // h_dist is the distance to the deposit area
                    double h_dist = h_dist = point->dist(deposit_area);

                    if (!cur_path.empty()) {
                        g_dist = point->dist(cur_path.back()->pos);
                    } else {
                        g_dist = point->dist(pos);
                    }

                    // if f_cost is lower set f_cost to cur_cost
                    if (g_dist + h_dist < b_f_cost || b_point == nullptr) {
                        ERROR_MESSAGE("Found better Point");
                        // check if point is already in path
                        if (std::find(cur_path.begin(), cur_path.end(), point) == cur_path.end()) {
                            ERROR_MESSAGE("Set new best point");
                            b_f_cost = g_dist + h_dist;
                            b_point = point;
                        }
                    }
                }
            }
            ERROR_MESSAGE("Found b_Point #" + std::to_string(b_point->color));
            t_loaded_objects[b_point->color]++;
            // The best point is added to the cur_path alongside with it's distance
            if (!cur_path.empty()) {
                cur_path_dist += b_point->dist(cur_path.back()->pos);
            } else {
                cur_path_dist += b_point->dist(pos);
            }
            cur_path.push_back(b_point);
        }
        // add the dist from the last point to the deposit_area
        cur_path_dist += cur_path.back()->dist(deposit_area);

        // if the overall path length is shorter then before -> set best to cur
        if (cur_path_dist < b_overall_dist || b_overall_dist == -1) {
            b_overall_dist = cur_path_dist;

            // this wont overfill because point_path gets set to cur_path and therefore forgets it's earlier content
            point_path = cur_path;
            t_deposit_area = deposit_area;
        }
    }

    return {point_path, t_deposit_area};

}

Point *MapData::getClosestPoint(std::pair<int, int> pos) {
    double b_dist = 0;
    Point *b_point = nullptr;
    for (const auto &p : MapData::getAllPoints()) {
        if (p->dist(pos) < b_dist || b_point == nullptr) {
            b_dist = p->dist(pos);
            b_point = p;
        }
    }
    return b_point;
}
